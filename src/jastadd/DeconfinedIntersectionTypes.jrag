aspect DeconfinedIntersectionTypes {

  syn Access IntersectionAccess.erasedAccess() = getAccess();

  /* erasure mapping preserving typing information */
  rewrite IntersectionAccess {
    to Access {
			/* DEBUG */
			System.err.println("rewriting IntersectionAccess to child Access at " + location());

			Access a = erasedAccess();
			Collection<Access> c = new ArrayList<>();

			for (Access additionalBound : getAdditionalBoundList()) {
				c.add(additionalBound);
			}

			a.setAdditionalAccessBounds(c);

      return a;
    }
  }

  syn boolean Variable.isIntersectionVariable();
  eq Declarator.isIntersectionVariable() = !(getTypeAccess().getAdditionalAccessBounds().isEmpty());
  eq ParameterDeclaration.isIntersectionVariable() = !(getTypeAccess().getAdditionalAccessBounds().isEmpty());
  eq EnumConstant.isIntersectionVariable() = false;
  eq CatchParameterDeclaration.isIntersectionVariable() = false;
  eq InferredParameterDeclaration.isIntersectionVariable() = false;

	/* additional type bounds backing field */
	private Collection<Access> Access._additionalAccessBounds = new ArrayList<>();

	protected void Access.setAdditionalAccessBounds(Collection<Access> c) {
		_additionalAccessBounds = c;
	}

	protected Collection<Access> Access.getAdditionalAccessBounds() {
		return _additionalAccessBounds;
	}

	syn boolean VarAccess.isIntersectionAccess() = decl().isIntersectionVariable();

  private boolean VarAccess._hasDoneIntersectionRewrite = false;

  protected boolean VarAccess.hasDoneIntersectionRewrite() {
    return _hasDoneIntersectionRewrite;
  }

  protected void VarAccess.setDoneIntersectionRewrite(Boolean b) {
    _hasDoneIntersectionRewrite = b;
  }

  /* testing assignment dest context information attribute */
  inh Variable Expr.destVariable();
  eq AssignExpr.getSource().destVariable() {
    if (getDest() instanceof VarAccess) {
      return ((VarAccess) getDest()).decl();
    }

    return null;
  }
  eq Declarator.getInit().destVariable() = this;
  eq MethodAccess.getArg(int index).destVariable() = decl().getParameter(index);

  /* TODO(cplrossi): add destVariable() eq for parameter declaration case */

  /*** translation ***/

  /* variable/parameter/field access */
  rewrite VarAccess {
    when (isIntersectionAccess()
          && !castContext()                 // TODO(cplrossi): test this
          && !simpleAssignment()            // not a lvalue
          && !hasDoneIntersectionRewrite()
          )
			to IntersectionCastExpr {
				/* DEBUG */
				System.err.println("found intersection var/param/field access at " + location());

				List<Access> l = new List();
				Access tAccess = null;

				if (decl() instanceof Declarator) {
					tAccess = ((Declarator) decl()).getTypeAccess();
				} else {	/* this branch is guarded by isIntersectionAccess() check */
					tAccess = ((ParameterDeclaration) decl()).getTypeAccess();
				}

				for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
					l.add(additionalBound.treeCopy());
				}

				Access a = tAccess.treeCopy();
        Expr e = this;

        setDoneIntersectionRewrite(true);

				return new IntersectionCastExpr(a, l, e);
			}
  }

  /* pure lambda intersection cast wrapping */
  rewrite LambdaExpr {
    when ((assignmentContext() || invocationContext())
          && !castContext()
          && destVariable() != null
          && destVariable().isIntersectionVariable()
          )
      to IntersectionCastExpr {
        List<Access> l = new List();
				Access tAccess = null;
        Variable v = destVariable();

				if (v instanceof Declarator) {
					tAccess = ((Declarator) v).getTypeAccess();
				} else {  /* TODO(cplrossi) check if we should guard this branch */
					tAccess = ((ParameterDeclaration) v).getTypeAccess();
				}

				for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
					l.add(additionalBound.treeCopy());
				}

				Access a = tAccess.treeCopy();
        Expr e = this.treeCopy();

        return new IntersectionCastExpr(a, l, e);
      }
  }
}
