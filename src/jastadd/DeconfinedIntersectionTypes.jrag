aspect DeconfinedIntersectionTypes {

  syn Access IntersectionAccess.erasedAccess() = getAccess();

  /* erasure mapping preserving typing information */
  rewrite IntersectionAccess {
    to Access {
      /* DEBUG */
      System.err.println("rewriting IntersectionAccess to child Access at " + location());

      Access a = erasedAccess();
      Collection<Access> c = new ArrayList<>();

      for (Access additionalBound : getAdditionalBoundList()) {
        c.add(additionalBound);
      }

      a.setAdditionalAccessBounds(c);

      return a;
    }
  }

  syn boolean Access.isIntersectionAccess() = false;
  eq TypeAccess.isIntersectionAccess() = !(getAdditionalAccessBounds().isEmpty());
  eq VarAccess.isIntersectionAccess() = decl().isIntersectionVariable();
  eq MethodAccess.isIntersectionAccess() = decl().hasIntersectionReturnValue();

  syn boolean Variable.isIntersectionVariable();
  eq Declarator.isIntersectionVariable() = getTypeAccess().isIntersectionAccess();
  eq ParameterDeclaration.isIntersectionVariable() = getTypeAccess().isIntersectionAccess();
  eq EnumConstant.isIntersectionVariable() = false;
  eq CatchParameterDeclaration.isIntersectionVariable() = false;
  eq InferredParameterDeclaration.isIntersectionVariable() = false;

  /* additional type bounds backing field */
  private Collection<Access> Access._additionalAccessBounds = new ArrayList<>();

  protected void Access.setAdditionalAccessBounds(Collection<Access> c) {
    _additionalAccessBounds = c;
  }

  protected Collection<Access> Access.getAdditionalAccessBounds() {
    return _additionalAccessBounds;
  }

  private boolean VarAccess._intersectionCastContext = false;

  protected boolean VarAccess.intersectionCastContext() {
    return _intersectionCastContext;
  }

  protected void VarAccess.setIntersectionCastContext(Boolean b) {
    _intersectionCastContext = b;
  }

  /* testing assignment dest context information attribute */
  eq Program.getChild().destVariable() = null;
  inh Variable ASTNode.destVariable();

  inh Variable Expr.destVariable();
  eq AssignExpr.getSource().destVariable() {
    if (getDest() instanceof VarAccess) {
      return ((VarAccess) getDest()).decl();
    }

    return null;
  }
  eq Declarator.getInit().destVariable() = this;
  eq MethodAccess.getArg(int index).destVariable() = decl().getParameter(index);
  eq ReturnStmt.getResult().destVariable() = null;

  /* method declaration */
  eq Program.getChild().enclosingMethodDecl() = null;
  inh MethodDecl ASTNode.enclosingMethodDecl();

  eq MethodDecl.getBlock().enclosingMethodDecl() = this;
  inh MethodDecl Stmt.enclosingMethodDecl();
  inh MethodDecl Expr.enclosingMethodDecl();

  /* */
  syn boolean MethodDecl.hasIntersectionReturnValue() =
    getTypeAccess().isIntersectionAccess();

  /* intersection return context */
  eq Program.getChild().intersectionReturnContext() = false;
  inh boolean ASTNode.intersectionReturnContext();

  eq ReturnStmt.getResult().intersectionReturnContext() =
    enclosingMethodDecl().hasIntersectionReturnValue();
  inh boolean Expr.intersectionReturnContext();

  private boolean MethodAccess._intersectionCastContext = false;

  protected boolean MethodAccess.intersectionCastContext() {
    return _intersectionCastContext;
  }

  protected void MethodAccess.setIntersectionCastContext(boolean b) {
    _intersectionCastContext = b;
  }

  /*** translation ***/

  /* wrapping variable/parameter/field access with intercast */
  rewrite VarAccess {
    when (isIntersectionAccess()
          && !intersectionCastContext()
          && !castContext()
          && !simpleAssignment()            // not a lvalue
    ) to IntersectionCastExpr {
      /* DEBUG */
      System.err.println("found intersection var/param/field access at " + location());

      List<Access> l = new List();
      Access tAccess = null;

      if (decl() instanceof Declarator) {
        tAccess = ((Declarator) decl()).getTypeAccess();
      } else {	/* this branch is guarded by isIntersectionAccess() check */
        tAccess = ((ParameterDeclaration) decl()).getTypeAccess();
      }

      for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
        l.add(additionalBound.treeCopy());
      }

      Access a = tAccess.treeCopy();
      Expr e = treeCopyNoTransform();

      ((VarAccess) e).setIntersectionCastContext(true);

      return new IntersectionCastExpr(a, l, e);
    }
  }

  /* wrapping method access with intercast */
  rewrite MethodAccess {
    when (!intersectionCastContext()    // DEVE ESSERE PER PRIMO
          &&isIntersectionAccess()
          && !castContext()
          && !(this instanceof BoundMethodAccess)
    ) to IntersectionCastExpr {
      /* DEBUG */
      System.err.println("found intersection method access at " + location());

      List<Access> l = new List();
      Access tAccess = decl().getTypeAccess();

      for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
        l.add(additionalBound.treeCopy());
      }

      Access a = tAccess.treeCopy();
      Expr e = treeCopyNoTransform();

      ((MethodAccess) e).setIntersectionCastContext(true);

      return new IntersectionCastExpr(a, l, e);
    }
  }

  /* wrapping pure lambda with intercast by type inference */
  rewrite LambdaExpr {
    when ((assignmentContext() || invocationContext())
          && !castContext()
          && destVariable() != null
          && destVariable().isIntersectionVariable()
    ) to IntersectionCastExpr {
      /* DEBUG */
      System.err.println("adding intercast to lambda expr in assign/invoke context");

      List<Access> l = new List();
			Access tAccess = null;
      Variable v = destVariable();

      if (v instanceof Declarator) {
        tAccess = ((Declarator) v).getTypeAccess();
      } else {  /* TODO(cplrossi) check if we should guard this branch */
        tAccess = ((ParameterDeclaration) v).getTypeAccess();
      }

      for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
        l.add(additionalBound.treeCopy());
      }

      Access a = tAccess.treeCopy();
      Expr e = treeCopy();

      IntersectionCastExpr ice = new IntersectionCastExpr(a, l, e);
      ice.setParent(getParent());

      return ice;
    }
    when (intersectionReturnContext()
          && !castContext()
    ) to IntersectionCastExpr {
      /* DEBUG */
      System.err.println("adding intercast to lambda expr in return stmt");

      List<Access> l = new List();
      Access tAccess = enclosingMethodDecl().getTypeAccess();

      for (Access additionalBound : tAccess.getAdditionalAccessBounds()) {
        l.add(additionalBound.treeCopy());
      }

      Access a = tAccess.treeCopy();
      Expr e = treeCopy();

      IntersectionCastExpr ice = new IntersectionCastExpr(a, l, e);
      ice.setParent(getParent());

      return ice;
    }
  }
}
