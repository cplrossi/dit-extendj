aspect IntersectionTypes {

  /* TODO(cplrossi): rename this to something link "DeconfinedIntersectionTypes" */

  syn Access IntersectionAccess.erasedAccess() = getAccess();

  /* erasure mapping preserving typing information */
  rewrite IntersectionAccess {
    to Access {
			/* DEBUG */
			System.err.println("rewriting IntersectionAccess to child Access at " + location());

			Access a = erasedAccess();
			Collection<Access> c = new ArrayList<>();

			for (Access additionalBound : getAdditionalBoundsList()) {
				c.add(additionalBound);
			}

			a.setAdditionalBounds(c);

      return a;
    }
  }

	/* additional type bounds backing field */
	private Collection<Access> Access._additionalBounds = new ArrayList<>();

	protected void Access.setAdditionalBounds(Collection<Access> c) {
		_additionalBounds = c;
	}

	protected Collection<Access> Access.getAdditionalBounds() {
		return _additionalBounds;
	}

	private boolean VarAccess._doneIntersectionRewrite = false;

	protected boolean VarAccess.isIntersectionAccess() {
		if (decl() instanceof Declarator) {
			return !((Declarator) decl()).getTypeAccess().getAdditionalBounds().isEmpty();
		} else if (decl() instanceof ParameterDeclaration) {
			return !((ParameterDeclaration) decl()).getTypeAccess().getAdditionalBounds().isEmpty();
		} else {
			return false;
		}
	}

	protected boolean VarAccess.hasDoneIntersectionRewrite() {
		return _doneIntersectionRewrite;
	}

	protected void VarAccess.setDoneIntersectionRewrite(boolean b) {
		_doneIntersectionRewrite = b;
	}

  /*** translation ***/

  /* variable/parameter access */
  /* TODO: test intersection fields */
  rewrite VarAccess {
    when (isIntersectionAccess() &&
            !simpleAssignment() &&
            !hasDoneIntersectionRewrite())
			to IntersectionCastExpr {
				/* DEBUG */
				System.err.println("found intersection var/param/field access at " + location());

				List<Access> l = new List();
				Access tAccess = null;

				if (decl() instanceof Declarator) {
					tAccess = ((Declarator) decl()).getTypeAccess();
				} else {	/* this branch is guarded by isIntersectionAccess() check */
					tAccess = ((ParameterDeclaration) decl()).getTypeAccess();
				}

				for (Access additionalBound : tAccess.getAdditionalBounds()) {
					l.add(additionalBound.treeCopy());
				}

				Access a = tAccess.treeCopy();

				/* no recurse forever */
				setDoneIntersectionRewrite(true);

				return new IntersectionCastExpr(a, l, this);
			}
  }

  /* TODO: rewrite CastExpr when Access is an intersection access (should fix
   * lambda target type inference)
   */

   // rewrite LambdaExpr {
   //   when (assignmentContext() &&
   //          !castContext()
   //          && getParent() instanceof AssignExpr
   //          && ((AssignExpr) getParent()).getDest() instanceof VarAccess
   //          && ((VarAccess)((AssignExpr) getParent()).getDest()).isIntersectionAccess() {
   //     to IntersectionCastExpr {
   //       System.err.println("found pure lambda expr in intersection type assignment context, rewriting as IntersectionCastExpr")
   //
   //       VarAccess dest =
   //     }
   //   }
   // }
}
